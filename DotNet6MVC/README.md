# DotNet6 Quickstart

**THIS IS A WORK IN PROGRESS**

The goal of this project is not to provide a template for you to clone.  
Instead, this guide will tell you how to expand on the built in templates that the `dotnet new` command provides.

This ensures that new projects will benefit from changes to the builtin templates, while also increasing understanding of changes that we suggest making.

This guide expects you to be using Visual Studio Code with the C# extension installed.

## Walthrough

This guide will focus on MVC as it the standard used by the majority of TC development teams.

### Initializing the project

Run this command in an empty folder where you want your project to be located.  
The name of this folder will determine the project name and namespace used by the autogenerated files.

```powershell
dotnet new mvc --auth SingleOrg
```

### Local auth config

This expects you to have already acquired an app registration in the Azure Active Directory.

From the autogenerated `appsettings.json`, replace the `AzureAd` block with the following:

```json
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "Domain": "tc.gc.ca",
    "CallbackPath": "/signin-oidc"
  },
```

Replace the following values with those associated with your app registration and run these commands to set the secrets needed to run.

```powershell
dotnet user-secrets set AzureAd:ClientId "11111111-1111-1111-11111111111111111"
dotnet user-secrets set AzureAd:TenantId "22222222-2222-2222-2222-222222222222"
```

This will allow the app to work without storing these values in your repo.  
See also: [should I consider my Azure tenant id a secret?](https://security.stackexchange.com/questions/238696/should-i-consider-my-azure-tenant-id-as-a-secret)

### Azure auth config

You will need to add the reply url to your app registration in the Azure portal to ensure you don't get errors while logging in.

_The port number can be omitted._

![Azure interface for adding reply URLs](./images/addreplyurl.png)

### Test run

At this point, you can test the app by running

```powershell
dotnet run
```

or by running

```powershell
dotnet watch run
```

which will reload the app when changes are made.

Alternatively, the C# extension will prompt you to add build configs which allows you to run using your VSCode shortcuts.

![VSCode prompting to add build configurations](./images/buildconfig.png)

Sometimes I get errors using the VSCode launch instead of the command, so try the command if you get weird errors such as `Index.cshtml not found`.

You should see your email in the top right if the signin is working.

![Web page loading successfully with user's email](./images/authtestgood.png)

If the reply urls are misconfigured, you will receive an error like this:

![Web page failing to load due to login error](./images/badreplyurl.png)

### Gitignore

The build process generates some files we don't care about.  
Rather than creating a `.gitignore` file manually, you can just use the following command:

```powershell
dotnet new gitignore
```

### Adding localization

[We are responsible for ensuring that we deliver content in both official languages](https://www.tbs-sct.gc.ca/pol/doc-eng.aspx?id=26164). This doesn't necessarily _require_ that the URL (beyond the domain name) is also localized, but it's not difficult to add.

Microsoft guides on ASP.NET localization are available [here](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/localization?view=aspnetcore-6.0), but the important steps will be copied to this document.

First we will create the file `Helpers/RouteDataRequestCultureProvider.cs`

```
using Microsoft.AspNetCore.Localization;

namespace DotNet6MVC.Helpers;

#nullable disable
public class RouteDataRequestCultureProvider : RequestCultureProvider
{
	public override Task<ProviderCultureResult> DetermineProviderCultureResult(HttpContext httpContext)
	{
		if (httpContext?.Request?.Path.Value == null)
			return Task.FromResult(new ProviderCultureResult(DefaultCulture));

		var culture = httpContext.Request.Path.Value.Split('/')[1];
		return Task.FromResult(Options.SupportedCultures.Any(x => x.TwoLetterISOLanguageName.Equals(culture, StringComparison.InvariantCultureIgnoreCase))
			? new ProviderCultureResult(culture)
			: new ProviderCultureResult(DefaultCulture));
	}

	private string DefaultCulture => Options.DefaultRequestCulture.Culture.TwoLetterISOLanguageName;
}
```

Inside `Program.cs` we want to add a few lines:

```diff
+ builder.Services.AddLocalization(options => options.ResourcesPath = "Resources");


builder.Services.AddControllersWithViews(options =>
{
+    options.EnableEndpointRouting = true;
    var policy = new AuthorizationPolicyBuilder()
        .RequireAuthenticatedUser()
        .Build();
    options.Filters.Add(new AuthorizeFilter(policy));
- });
+ })
+.AddViewLocalization();

...

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
-     app.UseExceptionHandler("/Home/Error");
+     app.UseExceptionHandler(o =>
+     {
+         o.Run(ctx =>
+         {
+             var language = ctx.Request.Path.Value?.Length >= 3 ? ctx.Request.Path.Value.Substring(1, 2) : "en";
+             if (language.Equals("en")) ctx.Response.Redirect($"{ctx.Request.PathBase.Value}/{language}/error");
+             if (language.Equals("fr")) ctx.Response.Redirect($"{ctx.Request.PathBase.Value}/{language}/erreur");
+             return Task.CompletedTask;
+         });
+     });
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

...

+ app.UseRequestLocalization(options =>
+ {
+     options.SupportedCultures = new[]{
+         new CultureInfo("en"),
+         new CultureInfo("fr")
+     };
+     options.DefaultRequestCulture = new Microsoft.AspNetCore.Localization.RequestCulture(options.SupportedCultures[0]);
+     options.RequestCultureProviders.Insert(0, new Microsoft.AspNetCore.Localization.Routing.RouteDataRequestCultureProvider { Options = options});
+ });

...

app.MapControllerRoute(
    name: "default",
-    pattern: "{controller=Home}/{action=Index}/{id?}");
+    pattern: "{culture}/{controller}/{action}/{id?}");

```

From here, we can add custom urls to our controller methods.  
In `HomeController.cs`

```diff
+    [HttpGet("/{culture:regex(en)}/home")]
+    [HttpGet("/{culture:regex(fr)}/hom")]
+    [HttpGet("/{culture:regex(en)}")]
+    [HttpGet("/{culture:regex(fr)}")]
+    [HttpGet("/")]
    public IActionResult Index()
    {
        return View();
    }
    
+    [HttpGet("/{culture:regex(en)}/privacy")]
+    [HttpGet("/{culture:regex(fr)}/privee")]
    public IActionResult Privacy()
    {
        return View();
    }

    
    [AllowAnonymous]
    [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
+    [HttpGet("/{culture:regex(en)}/error")]
+    [HttpGet("/{culture:regex(fr)}/erreur")]
    public IActionResult Error()
    {
        return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
    }
```

Note that this changes the route from `/Home/Privacy` to `/en/privacy` since we explicitly set the route.  
If we created a new endpoint without an `HttpGet` decorator, it would follow the normal convention.

For example:

```c#
public IActionResult Beans()
{
    return View();
}
```

This route would be accessible from `/en/Home/Beans` and `/fr/Home/Beans` (since the controller is called `Home`).  
Explicitly setting the routes lets them be fully localized.

### Adding WET

The Web Experience Toolkit (WET) framework enables government sites to share a common look and feel without having to [reimplement everything from scratch](https://www.canada.ca/en/treasury-board-secretariat/services/government-communications/federal-identity-program/technical-specifications/web-mobile-presence.html).

In this case, we can make our new app adopt the government theming by editing `Views/Shared/_Layout.cshtml`

Inside the `<head>` tag at the end:

```html
    @* WET CDTS *@
    <script src="https://ssl-templates.services.gc.ca/rn/cls/wet/gcintranet/cdts/compiled/soyutils.js"></script>
    <script src="https://ssl-templates.services.gc.ca/rn/cls/wet/gcintranet/cdts/compiled/wet-en.js"></script>
    <script>
        document.write(wet.builder.refTop({}));
    </script>
    
    @* Configure WET apptop TODO *@
    <script>
        let appTop = {
            appName: [{ text: "MyApp" }],
        };
    </script>
    @* Add per-page apptop config *@
    @await RenderSectionAsync("AppTop", required: false)
```

Inside the end of the `<body>` tag, remove the `<footer>` tag and add:

```html
    @* WET footer display *@
    <footer id="def-footer"></footer>
    <script>
        var defFooter = document.getElementById("def-footer");
        defFooter.innerHTML = wet.builder.footer({});
    </script>

    @* WET footer scripts *@
    <script>
        document.write(wet.builder.refFooter({}));
    </script>
```

Remove the `<header>` tag and add:

```html
    @* WET header *@
    <div id="def-top"></div>
    <script>
        var defTop = document.getElementById("def-top");
        defTop.innerHTML = wet.builder.appTop(appTop);
    </script>
```

Additionally, we want to remove the following lines since WET loads its own version of Bootstrap and JQuery.

```diff
# from <head>
- <link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" />

# from <body>
- <script src="~/lib/jquery/dist/jquery.min.js"></script>
- <script src="~/lib/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
```

We can also delete the contents of `wwwroot/lib`.

We can also clear the contents of `wwwroot/css/site.css`.

